package objects

import testing.eq
import testing.trace

/*
-> To read a property, use its name.

-> To assign a value to a mutable property,
use the assignment operator '='.

Property accessors provide a kind of protection
for properties.

Many OOP languages rely on making physical field
private to control access to that property.
With property accessors you can add code to
control or modify that access, while allowing
anyone to use a property.
 */
class Data(var i: Int)

/*
Property accessor are called during reads
and writes.
- getter
- setter

The definition fot get() and set() is unimportant.
You can define get() without defining set(), adn vice-versa
 */
class RickAndMorty {
    /*
    Inside the getter and setter, the stored value
    is manipulated indirectly using the 'field' keyword,
    which is only accessible within these two functions.
     */
    var greet: String = ""
    /*
    Property accessor (getter & setter) needs
    to be defined right after property declaration.
    The association happens because get() and set()
    are defined immediately after that property (Kotlin
    doesn't care about the indentation).

    getter and setter below imitate the default
    implementations generated by Kotlin.

    the field keyword only accessible
    within getter and setter.

    If you define a property as private,
    both accessors become private.
     */
    get() {
        trace("get()")
        return field
    }
    set(value) {
        trace("set($value)")
        field = value
    }

}

// Log Changes
class LogChanges {
    var n: Int = 0
        set(value) {
            trace("$field becomes $value")
            field = value
        }
}

// Counter
/*
private set and mutate property
from member function.
 */
class Counter {
    var value: Int = 0
        private set
    fun inc() = value++
}

/*
Normal properties store their data in a field.
You can also create a property that doesn't have a field.
 */
class Vehicle(val name: String)

class Garage(private val maxCapacity: Int) {
    private val vehicles = mutableListOf<Vehicle>()

    val capacity: Int
        get() = maxCapacity - vehicles.size
    val full: Boolean
        get() = vehicles.size == maxCapacity

    fun put(vehicle: Vehicle): Boolean =
        if (full) {
            false
        } else {
            vehicles += vehicle
            true
        }
    fun take(): Vehicle = vehicles.removeAt(0)
}
fun propertyNoField() {
    val garage = Garage(2)
    /*
    The properties capacities and full contain no underlying
    state--they are computed at the time of each access.
     */
    garage.full eq false
    garage.capacity eq 2
    garage.put(Vehicle("GTR")) eq true
    garage.put(Vehicle("Mazda")) eq true
    garage.full eq true
    garage.capacity eq 0
    garage.put(Vehicle("BMW")) eq false
    garage.take()
    garage.capacity eq 1
}

/*
Both capacity and full are similar to functions,
and you can define the like below.

Kotlin style guide prefers properties over functions
when the value is cheap to calculate and the property
returns the same results for each invocation as long
as the object state hasn't changed.
 */
class Garage2(private val maxCapacity: Int) {
    private val vehicles = mutableListOf<Vehicle>()

    fun capacity(): Int =
        maxCapacity - vehicles.size
    fun isFull(): Boolean =
        vehicles.size == maxCapacity
}
fun propertyNoField2() {
    val garage2 = Garage(2)
    /*
    The properties capacities and full contain no underlying
    state--they are computed at the time of each access.
     */
    garage2.full eq false
    garage2.capacity eq 2
    garage2.put(Vehicle("GTR")) eq true
    garage2.put(Vehicle("Mazda")) eq true
    garage2.full eq true
    garage2.capacity eq 0
    garage2.put(Vehicle("BMW")) eq false
    garage2.take()
    garage2.capacity eq 1
}

fun main() {
    val data = Data(10)
    // getter
    data.i eq 10 // Read the 'i' property
    // setter
    data.i = 20 // Write to the 'i' property
    /*
    Above getter and setter appears to be straightforward
    access to the piece of storage name i. However, Kotlin
    calls functions to perform the reads and writes the data
    store in the property i.
     */
    data.i eq 20

    println("-----------------")

    val rickAndMorty = RickAndMorty()
    rickAndMorty.greet = "ohh geez!"
    trace(rickAndMorty.greet)
    trace eq """
        set(ohh geez!)
        get()
        ohh geez!
    """.trimIndent()

    println("-----------------")

    val lc = LogChanges()
    lc.n eq 0
    lc.n = 2
    lc.n eq 2
    trace eq "0 becomes 2"

    println("-----------------")

    val counter = Counter()
    repeat(10) {
        counter.inc()
    }
    counter.value eq 10

    println("-----------------")

    propertyNoField()

    println("-----------------")

    propertyNoField2()
}